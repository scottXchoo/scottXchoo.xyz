---
emoji: 🕹️
title: 🕹️ [백준] 주사위 윷놀이 - 17825 | Gold 2 (파이썬)
date: '2023-11-23 10:30:00'
author: 추교현
tags: 완전탐색 구현
categories: 🕹️PS
---

[백준] 주사위 윷놀이 - 17825 | Gold 2.@

---

## 문제 요약

[문제 링크](https://www.acmicpc.net/problem/17825)

- 처음에 시작 칸에 말 4개
- 파란색 칸에서 이동을 시작하면 파란색 화살표, 그렇지 않으면 빨간색 화살표
- 게임은 10개의 턴 : 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위 굴림
- 말이 이동을 마치는 칸에 다른 말이 있으면 이동 불가 (단, 이동을 마치는 칸이 도착 칸이면 가능)
- 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가
- 주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값은?

## 정답 코드

```python
graph = [[1], [2], [3], [4], [5],
   [6, 21], [7], [8], [9], [10],
   [11, 25], [12], [13], [14], [15],
   [16, 27], [17], [18], [19], [20],
   [32], [22], [23], [24], [30],
   [26], [24], [28], [29], [24],
   [31], [20], [32]]

score = [0, 2, 4, 6, 8,
   10, 12, 14, 16, 18,
   20, 22, 24, 26, 28,
   30, 32, 34, 36, 38,
   40, 13, 16, 19, 25,
   22, 24, 28, 27, 26,
   30, 35, 0]

dice = list(map(int, input().split()))
ans = 0

def backtracking(depth, result, horses):
  global ans
  if depth == 10:
    ans = max(ans, result)
    return

  for i in range(4):
    x = horses[i] # 현재 말 위치

    # 현재 말 위치가 두 갈래 갈 수 있는 위치(10, 20, 30)인지 체크
    if len(graph[x]) == 2:
      # 파란 길 한 칸 진입
      x = graph[x][1]
    else:
      # 빨간 길 한 칸 진입
      x = graph[x][0]

    # 나온 주사위 값만큼 말 이동 (위에서 1칸 이동했기 때문에 1 덜 이동)
    for _ in range(1, dice[depth]):
      x = graph[x][0]

    # 목적지에 도착했거나 or (아직 목적지가 아니고 and 거기에 말이 없다면)
    if x == 32 or (x < 32 and x not in horses):
      before = horses[i] # 이전 말의 위치
      horses[i] = x # 현재 말 위치 갱신

      backtracking(depth+1, result+score[x], horses)

      horses[i] = before

backtracking(0, 0, [0, 0, 0, 0])
print(ans)
```

## 풀이 및 배운 점

무수히 많은 `경우의 수`가 떠오른다면, DFS 혹은 백트래킹을 생각해봅시다.

`for i in range(4): x = horses[i]`를 통해 각 말이 취할 수 있는 모든 경우를 적어줬습니다.

graph와 score를 이렇게 하드코딩으로 해결할 수도 있네요. 복잡한 그래프를 단순하게 표현할 줄 알아야 합니다.

빡센 구현은 시간도 오래 걸리고 확실히 어렵네요... 한 문제를 여러 번 반복하고 여러 풀이를 보며 학습하는 시간이 어느 정도 필요할 것 같아요.

---

"50대의 추교현이 20대의 추교현에게 감사할 수 있게끔 하루하루 최선을 다해 살고자 합니다."

**_The End._**
